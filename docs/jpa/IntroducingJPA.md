# JPA 소개
## SQL을 직접 다룰 때 발생하는 문제점
    관계형 데이터베이스는 가장 대중적이고 안전한 데이터 저장소로 거의 모든 웹 애플리케이션에서 사용된다. 
    데이터베이스 내부에서는 데이터를 관리하기 위해 SQL을 사용해야 하는데 자바로 개발된 애플리케이션은
    JDBC API를 사용하여 SQL을 데이터 베이스에 전달한다. 

### 예시 (JDBC를 사용하여 회원을 조회하는 예시. 테이블과 DAO가 만들어져 있다고 가정한다.)
```java
// 1. 회원 조회용 SQL을 작성한다. 
select M_ID, NAME from Member where M_ID = ? 

//2. JDBC API를 사용해서 SQL을 실행한다. 
//(풀 코드는 알 것이라고 생각하고 특정 부분만 작성한다. 하나의 SQL을 전달하기 위해 굉장히 긴 코드가 작성된다.)
ResultSet rs = stmt.executeQuery(sql);

//3. 조회한 결과를 매핑한다
String m_id = rs.getString("M_ID");
String name = rs.getString("NAME");

Member member = new Member();
member.setM_ID(m_id);
member.setName(name);
```

    CRUD하는 기능을 자바소스로 작성한다고 하면, MemberDao.java 파일에 위에는 많이 압축되었지만 굉장히 긴 코드가 4개가 작성될 것이다. 
    SQL을 직접 다루기 위해서 사용한다기에는 효율성이 너무 떨어져보인다. 
    데이터베이스가 아닌 컬렉션에 저장한다면 list.add(member)로 아주 편리하고 간단하게 저장할 수 있을텐데 말이다. 
    그 이유는 데이터베이스는 자바의 객체와는 다르게 <b>데이터 중심</b>의 구조를 가지기 때문에 객체 자체를 DB에 직접 저장할 수 없다. 
    따라서 개발자가 자바 소스와 DB 사이에서 이러한 구조 변환 작업을 통해 저장을 하기 때문에 코드가 길어질 수 밖에 없는 것이다.
    
### SQL에 의존적인 개발 
- 위에서 설계한 필드에는 회원의 연락처가 없었다. 그 상태로 CRUD개발을 마쳤더니 연락처도 추가해달라는 요구사항이 추가되었다고 가정해보자.
- 그렇다면 조회는 물론이고, 기존의 회원 관련 테이블에 대한 모든 코드에는 연락처와 관련된 코드가 추가되어야 한다.
- 이 코드가 10개일지 100개일지는 모르는 일이다.
- 또한 회원이 어떤 팀에 소속되어야 한다는 요구사항이 추가되면서 회원과 연관된 객체가 추가되었다고 가정해보고 문제점을 살펴보자. 
    
    회원 객체가 연관된 팀 객체를 사용할 수 있을지 없을지는 전적으로 사용하는 SQL에 달려 있다. 
    이런 방식의 가장 큰 문제점은 데이터 접근 계층을 사용해서 SQL을 숨겨도 어쩔 수 없이 DAO를 열어서 
    어떤 SQL이 실행되는지 일일히 확인해야 한다는 점이다.
    
    """애플리케이션이 SQL을 직접 다룰 때 발생하는 문제점 요약 """<br>
    Member나 Team처럼 비즈니스 요구사항을 모델링한 객체를 엔티티라고 한다.<br>
    지금처럼 SQL에 모든 것을 의존하는 상황에서는 개발자들이 엔티티를 신뢰할 수 없다.<br> 
    따라서 일일히 DAO를 열어서 SQL을 확인해야 하는데 이것은 진정한 의미의 계층 분할이 되었다고 할 수 없다.<br>
    즉, 엔티티와의 강한 의존관계 때문에 요구사항이 추가될때마다 기 작성된 대부분의 CRUD 코드와 SQL 대부분을 변경해야 한다. 
    
## 패러다임의 불일치
    애플리케이션은 자바라는 객체지향 언어로 개발하고, 데이터는 관계형 데이터베이스에 저장해야 한다. 
    객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다.
    나름 자바에서는 객체를 파일로 저장하기 위해 직렬화/역직렬화 기능을 제공하는데, 다 분해된 객체로 인해 검색이 어렵다 
    결국 관계형 데이터베이스에 데이터를 저장하는 것이 가장 효율적이고 현실적이지만, 관계형 DB는 객체와는 달리 데이터 중심으로 구조화되어 있고,
    집합적인 사고를 요구한다. 또한 객체지향에서 지원되는 다형성 같은 장치가 없다. 
    -> 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다른데 이것을 객체와 관계형DB의 패러다임 불일치 문제라고 한다.
       결론적으로 이러한 패러다임 불일치 문제를 극복하고 객체와 관계형DB를 함께 사용하기 위해서는 개발자가 중간에서 해결해야 한다. 
       이렇게 발생하는 문제들과 JPA가 어떻게 해결해주는지를 알아보자.

### 1. 상속
자바와는 다르게 관계형 데이터베이스는 상속을 지원하지 않는다. <br>
일부 DB는 지원한다고 하지만 객체의 상속과는 다르고 보편적인 관점에서 바라보자. <br>

예를 들어 아래와 같은 구조의 모델이 있다고 가정해보자.
```java
abstract class Item{
  Long id; 
  String name; 
  int price;
}

class Album extends Item{
  String artist;
}


class Movie extends Item{
  String director;
  String actor;
}


class Book extends Item{
  String author;
  String isbn;
}
```
- Album 객체를 저장하려면 연관된 객체(Item)를 고려하여 SQL을 2개 만들어야 한다(연관된 데이터가 소실되지 않도록). 다른 객체도 마찬가지다.
  - INSERT INTO ITEM ...
  - INSERT INTO ALBUM ...
- JDBC API를 사용해서 이 코드를 완성하려면 부모 객체에서 부모의 데이터만 꺼내서 ITEM용 INSERT SQL을 작성하고,
- 자식 객체에서 자식의 데이터만 꺼내서 ALBUM용 INSERT SQL을 작성해야 하는데, 예제이기 때문에 실제 애플리케이션보단 적지만 작성해야 될 코드가 만만치 않다.
- 이러한 일련의 과정들이 패러다임의 불일치를 해결하기 위해 개발자가 소모해야 하는 비용이다. 


### 1-1. JPA와 상속
* JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해준다.
* 개발자는 마치 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 된다. 
```java
//객체 저장(등록)
jpa.persist(album);

//객체 조회
String albumId = "id100";
Album album = jpa.find(Album.class, albunId);

//실제로는 JPA가 ITEM과 ALBUM테이블을 개발자 대신 조인해서 필요한 데이터를 조회하고 그 결과를 반환하는 것이다. 
SELECT I.*, A.*
  FROM ITEM I 
  JOIN ALBUM A ON I.ITEM_ID = A.ITEM_ID
```

### 연관 관계
* 객체는 참조를 통해서 다른 객체와의 연관 관계를 가지고, 참조에 접근해서 연관된 객체를 조회한다. 
* 테이블은 외래키를 가지고 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다.

![image](https://user-images.githubusercontent.com/87313203/231955456-d8503a13-40d2-4fee-af90-d617f2dabc5c.png)

