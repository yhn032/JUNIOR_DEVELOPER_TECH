# JPA란 무엇인가? 
* Java Persistence API는 자바 진영의 Object-Relational Mapping 기술 표준이다. 
* 애플리케이션과 JDBC 사이에서 동작한다. 

![image](https://user-images.githubusercontent.com/87313203/231960599-1803c403-e555-4e46-bbaf-18dedcee3747.png)
    ORM이란 말 그대로 객체와 관계형 데이터베이스를 매핑해준다는 의미이다. 
    패러다임 불일치로 인한 중간 과정을 개발자 대신 해주는 프레임 워크로 생각하자. 
    

# 영속성 관리 

* 엔티티 매니저 팩토리 : 엔티티 매니저를 만들어주는 팩토리 메소드
  * 생성 비용이 아주 크다. 
  * 여러 스레드가 동시에 접근해도 안전하다. 
* 엔티티 매니저 : 공장에서 생성하는 엔티티 매니저 
  * 생성 비용이 아주 작다. 
  * 동시성 문제가 있기 때문에 스레드 간에 공유하면 안 된다.   

### 영속성 컨텍스트
* 엔티티를 영구 저장하는 환경 (논리적인 개념)
* 엔티티 매니저를 통해 엔티티를 저장하고 조회하면 엔티티 매니저가 해당 엔티티를 영속성 컨텍스트에 보관하고 관리한다. 
* 엔티티 매니저 하나를 생성할 때마다 하나의 영속성 컨텍스트가 생성되고, 엔티티 매니저가 이 컨텍스트를 관리한다.

### 엔티티의 생명주기
![image](https://user-images.githubusercontent.com/87313203/231962897-5f65c9c4-2bfa-4586-8625-ef748fd1bee3.png)
* 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계 없는 상태. 아직 영속성 컨텍스트에 저장된 적이 없는 상태
* 영속(managed) : 영속성 컨텍스트에 저장된 상태. 엔티티 매니저에 의해 조회 및 관리 가능
  * em.find()나 JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태이다.
  * 단, 반드시 @Transactional인 상태에서 조회되어야 한다. 그렇지 않으면 준영속 상태로 됨.  
* 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
  * em.detach() or em.clear(), em.close() 
* 삭제(removed) : 삭제된 상태
  * em.remove()

### 영속성 컨텍스트의 특징 
1. 1차 캐시
2. 동일성 보장
3. 트랜잭션을 지원하는 쓰기 지연
4. 변경 감지
5. 지연 로딩

### 1차 캐시
* 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 "1차 캐시"라고 한다. 
* Map과 같은 구조로 Key : Value값으로 매핑되어 저장된다. 
* Value값은 저장되어 영속화 된 엔티티고, Key는 @Id로 매핑한 식별자 즉, 데이터베이스의 기본키 값이다. 

그림과 함께 소스코드를 보면서 1차 캐시의 개념을 살펴보자
1. 엔티티를 저장(영속화)
![image](https://user-images.githubusercontent.com/87313203/231966531-671a8e27-5814-4ac4-b588-740cb4e58681.png)

* 소스코드를 실행하면 이미지와 같이 논리적으로 키값에 매핑되어 1차 캐시에 저장된다. 그렇다면 1차 캐시에서 조회되는 과정을 살펴보자 

2. 1차 캐시에서 조회
![image](https://user-images.githubusercontent.com/87313203/231967256-85d22d6e-3676-4d07-bad3-2eb2fc18f40a.png)
* find함수나 JPQL을 사용하면 먼저 1차 캐시에서 식별자 값을 찾아본다. 
* 만약 찾고자 하는 엔티티가 존재하면 엔티티를 반환하고, 존재하지 않으면 그 때 데이터베이스를 조회한다.

3. 데이터 베이스에서 조회 
![image](https://user-images.githubusercontent.com/87313203/231968650-14ff7742-88e8-4896-b3fd-0184dacc7eb2.png)
* 찾고자 하는 엔티티가 1차 캐시에 없다면 
* DB에서 찾아온 후에 찾은 엔티티를 1차 캐시에 저장한다.(영속) 
* 찾은 엔티티를 반환한다.
* 매 순간 DB를 조회하는 것이 아니기 때문에 조회 성능상 이점이 있다. 

### 동일성 보장
